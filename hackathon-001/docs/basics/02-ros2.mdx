# Chapter 2: Introduction to ROS 2

ROS 2 (Robot Operating System 2) is a flexible framework for writing robot software.  
It provides the middleware, tools, and libraries necessary to build complex robotic applications.

---

## 2.1 What is ROS 2?

ROS 2 is the next-generation version of ROS, designed for real-time systems, multi-robot communication, and modern middleware support.  
Key features include:

- **DDS (Data Distribution Service)**: Reliable communication between nodes  
- **Multi-platform support**: Linux, Windows, macOS  
- **Real-time safety**: Suitable for industrial and autonomous robots  
- **Modular architecture**: Nodes, topics, services, actions, parameters

---

## 2.2 ROS 2 Core Concepts

### 2.2.1 Nodes
- Nodes are individual processes that perform computation.  
- Each node can communicate with other nodes using topics, services, or actions.

### 2.2.2 Topics
- Topics are named buses for **asynchronous message passing** between nodes.  
- Example: A camera node publishes images on `/camera/image_raw`.

### 2.2.3 Services
- Services provide **synchronous request/response communication**.  
- Example: Request the robot to move to a target location.

### 2.2.4 Actions
- Actions are **long-running tasks** with feedback.  
- Example: Move a robotic arm to pick up an object while providing progress updates.

### 2.2.5 Parameters
- Nodes can use parameters to **configure behavior at runtime** without changing code.  

---

## 2.3 ROS 2 Workspace

1. **Create a workspace**
```bash
mkdir -p ~/ros2_ws/src
cd ~/ros2_ws
colcon build

# Source the workspace
source install/setup.bash


# Example ROS 2 Python Node
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class TalkerNode(Node):
    def __init__(self):
        super().__init__('talker')
        self.publisher_ = self.create_publisher(String, 'chatter', 10)
        self.timer = self.create_timer(1.0, self.timer_callback)

    def timer_callback(self):
        msg = String()
        msg.data = 'Hello from ROS 2!'
        self.publisher_.publish(msg)
        self.get_logger().info(f'Publishing: "{msg.data}"')

def main(args=None):
    rclpy.init(args=args)
    node = TalkerNode()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
